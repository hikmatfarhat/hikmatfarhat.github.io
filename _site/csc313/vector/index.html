

<!doctype html>
<html lang="en" class="no-js">
  <head>
    

<meta charset="utf-8">



<!-- begin SEO -->









<title>Hikmat Farhat</title>







<meta property="og:locale" content="en-US">
<meta property="og:site_name" content="Hikmat Farhat">
<meta property="og:title" content="Hikmat Farhat">


  <link rel="canonical" href="http://localhost:4000/csc313/vector/">
  <meta property="og:url" content="http://localhost:4000/csc313/vector/">


















  <script type="application/ld+json">
    {
      "@context" : "http://schema.org",
      "@type" : "Person",
      "name" : "Hikmat Farhat",
      "url" : "http://localhost:4000",
      "sameAs" : null
    }
  </script>






<!-- end SEO -->


<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Hikmat Farhat Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">

<meta http-equiv="cleartype" content="on">
    

<!-- start custom head snippets -->

<link rel="apple-touch-icon" sizes="57x57" href="http://localhost:4000/images/apple-touch-icon-57x57.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="60x60" href="http://localhost:4000/images/apple-touch-icon-60x60.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="76x76" href="http://localhost:4000/images/apple-touch-icon-76x76.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="120x120" href="http://localhost:4000/images/apple-touch-icon-120x120.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="152x152" href="http://localhost:4000/images/apple-touch-icon-152x152.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:4000/images/apple-touch-icon-180x180.png?v=M44lzPylqQ">
<link rel="icon" type="image/png" href="http://localhost:4000/images/favicon-32x32.png?v=M44lzPylqQ" sizes="32x32">
<link rel="icon" type="image/png" href="http://localhost:4000/images/android-chrome-192x192.png?v=M44lzPylqQ" sizes="192x192">
<link rel="icon" type="image/png" href="http://localhost:4000/images/favicon-96x96.png?v=M44lzPylqQ" sizes="96x96">
<link rel="icon" type="image/png" href="http://localhost:4000/images/favicon-16x16.png?v=M44lzPylqQ" sizes="16x16">
<link rel="manifest" href="http://localhost:4000/images/manifest.json?v=M44lzPylqQ">
<link rel="mask-icon" href="http://localhost:4000/images/safari-pinned-tab.svg?v=M44lzPylqQ" color="#000000">
<link rel="shortcut icon" href="/images/favicon.ico?v=M44lzPylqQ">
<meta name="msapplication-TileColor" content="#000000">
<meta name="msapplication-TileImage" content="http://localhost:4000/images/mstile-144x144.png?v=M44lzPylqQ">
<meta name="msapplication-config" content="http://localhost:4000/images/browserconfig.xml?v=M44lzPylqQ">
<meta name="theme-color" content="#ffffff">
<link rel="stylesheet" href="http://localhost:4000/assets/css/academicons.css"/>

<script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML' async></script>

<!-- end custom head snippets -->

  </head>

  <body>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->
    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <button><div class="navicon"></div></button>
        <ul class="visible-links">
          <li class="masthead__menu-item masthead__menu-item--lg"><a href="http://localhost:4000/">Hikmat Farhat</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://localhost:4000/publications/">Publications</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://localhost:4000/teaching/">Teaching</a></li>
          
        </ul>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    





<div id="main" role="main">
  


  <div class="sidebar sticky">
  



<div itemscope itemtype="http://schema.org/Person">

  <div class="author__avatar">
    
    	<img src="http://localhost:4000/images/profile.jpg" class="author__avatar" alt="Hikmat Farhat">
    
  </div>

  <div class="author__content">
    <h3 class="author__name">Hikmat Farhat</h3>
    <p class="author__bio">Professor of Computer Science</p>
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li><i class="fa fa-fw fa-map-marker" aria-hidden="true"></i> Lebanon</li>
      
      
      
      
      
       
      
        <li><a href="https://twitter.com/hikmatfarhat"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
      
      
      
      
        <li><a href="https://www.linkedin.com/in/hikmat-farhat-3b562b41"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
      
      
      
      
      
      
        <li><a href="https://github.com/hikmatfarhat-ndu"><i class="fab fa-fw fa-github" aria-hidden="true"></i> Github</a></li>
      
      
        <li><a href="https://www.stackoverflow.com/users/13505760/hikmat-farhat"><i class="fab fa-fw fa-stack-overflow" aria-hidden="true"></i> Stackoverflow</a></li>
      
      
      
      
      
      
      
      
      
      
      
      
      
        <li><a href="http://scholar.google.com/citations?hl=en&user=bjI9-9kAAAAJ&view_op=list_works&sortby=pubdate"><i class="fas fa-fw fa-graduation-cap"></i> Google Scholar</a></li>
      
      
      
        <li><a href="https://orcid.org/0000-0002-5043-227X?lang=en"><i class="ai ai-orcid-square ai-fw"></i> ORCID</a></li>
      
      
      
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          
          
        
        
        
        
             
        
    
        </header>
      

      <section class="page__content" itemprop="text">
        
<p>Many of the data structures that we will be studying and implementing are already implemented in the Standard Template Library (STL). Our strategy is to use and familiarize ourselves with the provided containers and algorithms and then implement them ourselves.</p>
<h1 id="vector-container">Vector container</h1>
<p>A vector is basically a dynamic array. We can add and remove elements from it and it auto resizes itself. Since we would like to store any type of objects in a vector the implementation uses templates to pass any type to the vector. A vector has the all usual syntax of arrays, specifically the indexing.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
int main(){
    //declare a vector of int. creates an empty vector
    std::vector&lt;int &gt; v;
    //declare a vector of strings
    std::vector&lt;std::string &gt; sv;
    //add elements to the end
    v.push_back(1);
    v.push_back(2);
    sv.push_back("one");
    sv.push_back("two");
    //print all elements similar to arrays
    for(int i=0;i&lt;sv.size();++i)
        std::cout&lt;&lt;sv[i]&lt;&lt;",";
    std::cout&lt;&lt;"\n";
    //print all elements using range-based for loop
    for(auto x:v)
        std::cout&lt;&lt;x&lt;&lt; ",";
    std::cout&lt;&lt;"\n";   
}
</code></pre></div></div>
<p>You can try the code <a href="https://repl.it/@hfarhat/vector-ex1">here</a>
The <code class="language-plaintext highlighter-rouge">push_back</code> member function adds an element at the end of the vector. Above we have used two features from c++11: auto and range-based for loops. As you can see we can create a vector of any type (note the syntax). 
<strong>Note</strong>: since the type of an auto variable is inferred by the compiler it cannot be used with <em>uninitialized</em> variables.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>auto x;//error
auto y=1;//OK
</code></pre></div></div>
<h2 id="automatic-allocation">Automatic allocation</h2>

<p>In a typical use case when we use <code class="language-plaintext highlighter-rouge">push_back</code> we don’t know in advance the size of the data. If memory allocated to the vector is “full” then the vector needs to allocate more space <strong>and</strong> copy the existing data to the new storage space before adding the new values.
Let us look an example using arrays</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //create an array of two elements
        int size = 2;
        int* p = new int[2];
        for (int i = 0; i &lt; 10; ++i) {
            if (i == size) {//array is full
                std::cout &lt;&lt; "copying\n";
                int* old = p;
                p = new int[size + 1];
                for (int j = 0; j &lt; size; ++j)
                    p[j] = old[j];
                size++;
            }
            p[i] = i;

        }
        std::cout &lt;&lt; "------content-------\n";
        for (int i = 0; i &lt; size; ++i)
            std::cout &lt;&lt; p[i] &lt;&lt; ",";
        std::cout &lt;&lt; "\n";
</code></pre></div></div>
<p>It is obvious from the example that there is a lot of copying. In fact if we add <em>n</em> numbers there will be <em>n<sup>2</sup></em> operations. A smarter strategy would be to overallocate. The overallocation is STL implementation dependent. A good rule of thumb, used by the g++ STL, is to double the size every time.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {
        //create an array of two elements
        int size = 2;
        int* p = new int[2];
        for (int i = 0; i &lt; 10; ++i) {
            if (i == size) {//array is full
                std::cout &lt;&lt; "copying\n";
                int* old = p;
                p = new int[2*size];
                for (int j = 0; j &lt; size; ++j)
                    p[j] = old[j];
                size*=2;
            }
            p[i] = i;

        }
        std::cout &lt;&lt; "------content-------\n";
        for (int i = 0; i &lt; size; ++i)
            std::cout &lt;&lt; p[i] &lt;&lt; ",";
        std::cout &lt;&lt; "\n";
    }
</code></pre></div></div>
<p>But as you can see in the output, after the 10th element the values are arbitrary. This is because we didn’t differentiate between <strong>size</strong> and <strong>capacity</strong>. This is exactly how a vector handles allocated memory.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {   std::vector&lt;int&gt; v;
         for (int i = 0; i &lt; 100; i++) {
        std::cout &lt;&lt; "i= " &lt;&lt; i &lt;&lt; ", capacity=" &lt;&lt; v.capacity() &lt;&lt; std::endl;
        v.push_back(i);
          }
    }
</code></pre></div></div>
<p>If you run the above you will see the effect of preallocating memory. <strong>Note</strong>: it seems the msc++ uses a different preallocation strategy. From what i see it looks that the size is incremented 50% every time instead of 100%.</p>
<h3 id="iterators">Iterators</h3>
<p>Iterators are generalization of pointers and present a common interface to all STL containers and algorithms. For an array a pointer is sufficient since the elements of an array form a contiguous location in memory. What if the elements are not stored contiguously? Since every container stores the elements differently it implements its own methods to <em>iterate</em> over its elements. This has the added value that the user does not need to know the internal workings of the container in order to be able to use it.
 Given a container <strong>c</strong> and iterator <strong>itr</strong> points at an element stored in <strong>c</strong>. Therefore dereferencing an iterator <strong>(*itr)</strong> will return the element itself. Also iterators can be incremented and decremented like pointers: (itr++) and (itr–). Furthermore, every container <strong>c</strong> has a <strong>begin</strong> and <strong>end()</strong> method. As an example, suppose that we have a container that stores an integer sequence from 0 to n-1 but even numbers first then odd numbers. For example, 0,2,4,6,8,1,3,5,7,9. Below is a code that allow us to iterate over the values in order</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Container {
    int* p, * _begin;
protected:
    int _size;
    int *_end;
public:
    class Iterator {
        int* current;
        int _size;
    public:
        Iterator(int* p,int size) :current(p),_size(size) {}
        Iterator operator++() {
            
            if (*current == _size-1)current = current + 1;
            else if (*current % 2 == 0)
                current = current + _size / 2;
            else
                current = current-_size/2+1;
            return *this;
        }
        int operator *() {
            return *current;
        }
        bool operator!=(const Iterator&amp; rhs) {
            return current != rhs.current;
        }
        
    };
    Container(int size) :_size(size) {
        p = new int[_size];
        _begin = p;
        _end = p + size;
        for (int i = 0; i &lt; _size; ++i) {
            if (i % 2 == 0)
                p[i / 2] = i;
            else
                p[_size / 2 + i / 2] = i;
        }
    }
    Iterator begin() {
        return Iterator(_begin,_size);
    }
    Iterator end() {
        return Iterator(_end,_size);
    }
};

</code></pre></div></div>
<p>so we can print the values in order as follows:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Container c(10);
    for (Container::Iterator itr = c.begin(); itr != c.end(); ++itr)
        std::cout &lt;&lt; *itr &lt;&lt; ",";

</code></pre></div></div>
<p>Note the syntax for a dependent type (we could have used auto) because Iterator is a nested class. Similarly to the above we can use iterators with any STL container. In particular with vectors.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
int main(){
  std::vector&lt;std::string&gt; sv;
  sv.push_back("one");
  sv.push_back("two");
  for(auto itr=sv.begin();itr!=sv.end();itr++){
      std::cout&lt;&lt;(*itr)&lt;&lt;std::endl;
  }
}  
</code></pre></div></div>
<p>The auto keyword is useful since otherwise we have to write down the long type of the iterator: (since it is an iterator to container of type <code class="language-plaintext highlighter-rouge">std::vector&lt;std::string&gt;</code>)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::vector&lt;std::string&gt;::iterator itr;
</code></pre></div></div>
<p>vectors can be used similarly to arrays.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::vector&lt;int&gt; iv;
iv.push_back(1);
iv.push_back(2);
for(int i=0;i&lt;iv.size();i++)
  iv[i]=i;
</code></pre></div></div>
<p>Since vectors are required by the c++ standard to use contiguous memory 
it is best to add and remove(as opposed to change) from the end of a vector.
We still can insert and erase elements at arbitrary position using iterators but it is a <em>costly</em> operation.</p>

<h2 id="pre-allocation">Pre allocation</h2>

<p>In what follows we will use a TestClass</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;int nodebug=0&gt;
struct TestClass {
    int _x, _y;
    TestClass(int x = 0, int y = 0) :_x(x), _y(y) {
       if(!nodebug) std::cout &lt;&lt; "ctor\n";

    }
    TestClass(const TestClass&amp; rhs) {
        if(!nodebug)std::cout &lt;&lt; "copy ctor\n";
        _x = rhs._x;
        _y = rhs._y;
    };
    TestClass&amp; operator=(const TestClass&amp; rhs) {
        if(!nodebug)std::cout &lt;&lt; "assignment\n";
        _x = rhs._x;
        _y = rhs._y;
        return *this;
    }
     std::pair&lt;int, int&gt; val() {
        return std::pair&lt;int, int&gt;(_x, _y);
    }
    int&amp; x() {
        return _x;
    }
    int&amp; y() {
        return _y;
    }
    ~TestClass() {
        if(!nodebug)std::cout &lt;&lt; "dtor\n";
    }
};
</code></pre></div></div>
<p>Let us see what happens when we add objects of type TestClass to a vector.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::vector&lt;TestClass&lt;0&gt;&gt; v;
TestClass a(1,2);
TestClass b(3,4);
v.push_back(a);
v.push_back(b);
</code></pre></div></div>
<p>if we run the above we get the following output</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctor
ctor
copy ctor
copy ctor
copy ctor
...
</code></pre></div></div>
<p>You can try the code <a href="https://repl.it/@hfarhat/vector-ex2">here</a>
Obviously there are two calls for the constructor for a and b. The method push_back saves a <strong>copy</strong> of the input hence the two calls for the copy constructor. The third call for the copy constructor is because the vector was resized to accommodate b.</p>

<p>Sometimes it is useful to preallocate memory to minimize the number of copy operations when the vector is resized. There are two ways of doing this.</p>
<ol>
  <li>Specifying the size when the vector is created</li>
  <li>Using the vector::reserve method
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
 std::vector&lt;TestClass&lt;0&gt;&gt; v(2);
 TestClass a(1, 2);
 TestClass b(3, 4);
 v[0] = a;
 v[1] = b;
 std::cout &lt;&lt; "size= " &lt;&lt; v.size() &lt;&lt; std::endl;
 std::cout &lt;&lt; "----------------\n";

 }
 {
 std::vector&lt;TestClass&lt;0&gt;&gt; v;
 v.reserve(2);
 TestClass a(1, 2);
 TestClass b(3, 4);
 v.push_back(a);
 v.push_back(b);
 std::cout &lt;&lt; "size= " &lt;&lt; v.size() &lt;&lt; std::endl;
 std::cout &lt;&lt; "----------------\n";
 }
</code></pre></div>    </div>
    <p>The output of the above code is</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctor
ctor
ctor
ctor
assignment
assignment
size= 2
----------------
ctor
ctor
copy ctor
copy ctor
size= 2
----------------
</code></pre></div>    </div>
    <p>This is because not only the vector constructor reserves space for two objects but it will also call the default constructor of the object to initialize the reserved space. In this case we use the index operator to change the values. Whereas the member function reserve does not create objects when it reserves space.
Removing elements from the <strong>end</strong> of the vector is done using <code class="language-plaintext highlighter-rouge">pop_back()</code></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
 std::vector&lt;TestClass&lt;0&gt;&gt; v;
 v.push_back(TestClass&lt;0&gt;(1, 2));
 v.push_back(TestClass&lt;0&gt;(3, 4));
 std::cout &lt;&lt; v.size() &lt;&lt; std::endl;
 v.pop_back();
 std::cout &lt;&lt; v.size() &lt;&lt; std::endl;

 }
</code></pre></div>    </div>
    <h2 id="insertion-and-deletion">insertion and deletion</h2>
    <p>So far we added and removed elements from the <strong>end</strong> of the vector. We can do the same operations at arbitrary positions using iterators even though if these operations are to be done repeatedly a vector is not the best data structure to use.</p>
    <h3 id="insertion">insertion</h3>
    <p>The code below uses the <em>insert</em> function to add an element between <strong>a</strong> and <strong>b</strong> of the vector.</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
std::vector&lt;TestClass&lt;0&gt;&gt; v;
v.reserve(4);
TestClass&lt;0&gt; a(1,2);
TestClass&lt;0&gt; b(3,4);
TestClass&lt;0&gt; c(5,6);
TestClass&lt;0&gt; d(7,8);
v.push_back(a);
v.push_back(b);
v.push_back(c);

 auto itr=v.insert(v.begin()+1,d);
    for (auto i = v.begin(); i != v.end(); ++i) {
        if (i == itr)std::cout &lt;&lt; "element inserted here: ";
        std::cout &lt;&lt; i-&gt;x() &lt;&lt; "," &lt;&lt; i-&gt;y() &lt;&lt; std::endl;

    }
}

</code></pre></div></div>
<p>If you inspect the output you will see the following happening</p>
<ol>
  <li>ctor is used to create a,b,c,d.</li>
  <li>copy ctor is used to to copy the values of a,b,c to the vector (push_back)</li>
  <li>copy ctor is used to make a copy of d</li>
  <li>copy ctor is used to copy the value of c the 4th place that was reserved in the vector.</li>
  <li>Assignment is used to overwrite the 3rd place by the value of b</li>
  <li>Assignment is used to overwrite the 2nd place by the value of d</li>
</ol>

<p>This means that inserting a value in a vector any place other than the end will cause order of <strong>n</strong> copy/assignments. If such insertions are done often then a vector is not the optimal data structure to use. Note that the return value of insert is an iterator to the element that was inserted.
Similarly, we can erase values from a vector at arbitrary positions</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  {
  std::vector&lt;TestClass&lt;0&gt;&gt; v(5);
  TestClass&lt;0&gt; a(1, 2);
  TestClass&lt;0&gt; b(3, 4);
  v[0] = a;
  v[1] = b;
  std::cout &lt;&lt; "size= " &lt;&lt; v.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; "----------------\n";
  v.erase(v.begin());
  std::cout &lt;&lt; "-------done----\n";
  }


</code></pre></div></div>
<p>Since the deleted element is at the beginning of the vector it also triggers an order of <strong>n</strong> assignments to move values to the left.
Because of that, if you need to remove multiple items meeting a certain criterion, it is better to use the remove/erase idiom. We illustrate with two different ways of removing elements whose <strong>y</strong> value is 2 from a vector. The first, goes through a loop and when it finds an element with y==2 it erases it. Note that erase returns an iterator to the element <strong>after</strong> the erased one.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
std::vector&lt;TestClass&lt;0&gt;&gt; v;
v.reserve(4);
TestClass&lt;0&gt; a(1, 2);
TestClass&lt;0&gt; b(3, 4);
TestClass&lt;0&gt; c(5, 2);
TestClass&lt;0&gt; d(5, 6);
v.push_back(a); v.push_back(b); v.push_back(c); v.push_back(d);
std::cout &lt;&lt; "---searching--\n";
for (auto itr = v.begin(); itr != v.end();) {
    if (itr-&gt;y() == 2) {
        itr=v.erase(itr);
    }
    else itr++;
}
std::cout &lt;&lt; "----done searching\n";
  }


</code></pre></div></div>
<p>The second, more efficient way is to use the std::remove_if then erase. The function std::remove_if doesn’t actually remove elements, it “moves all elements meeting the criterion towards the end” of the vector and returns an iterator to the first one.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
{
    std::vector&lt;TestClass&lt;0&gt;&gt; v;
    v.reserve(4);
    TestClass&lt;0&gt; a(1, 2);
    TestClass&lt;0&gt; b(3, 4);
    TestClass&lt;0&gt; c(5, 2);
    TestClass&lt;0&gt; d(5, 6);
    v.push_back(a); v.push_back(b); v.push_back(c); v.push_back(d);
    std::cout &lt;&lt; "---searching--\n";
    auto itr=std::remove_if(v.begin(), v.end(), [](auto&amp; t) { return t.y() == 2; });
    v.erase(itr, v.end());
    std::cout &lt;&lt; "----done searching\n";
}

</code></pre></div></div>

<h3 id="accumulate">accumulate</h3>

<p>The standard fold operation in functional languages is implemented using the std::accumulate function. It takes a range (i.e. start and end iterators) and an initial value (usually zero). By default accumulate adds all the numbers in the range. so</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::accumulate(start,end,init);
</code></pre></div></div>
<p>is equivalent to</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::accumulate(start,end,init,std::plus{});
</code></pre></div></div>
<p>This means we can change the default behavior by supplying our own function. Accumulate works by repeatedly calling (default case plus) the function on the current element and the accumulated value starting with *start and init. The example below multiplies all the elements of the vector.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::vector&lt;int&gt; v {1,2,3,4};
auto res=std::accumulate(v.begin(),v.end(),1,std::multiplies{});
</code></pre></div></div>
<p>A more complicate example is shown below where we add the even and odd numbers separately.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {
     std::random_device e;
     std::uniform_int_distribution&lt;&gt; dist(1, 10);
     const int n = 10;
     std::vector&lt;int&gt; v(n);
     std::generate(v.begin(), v.end(), [&amp;]() {return dist(e); });
     for (auto&amp; x : v)
         std::cout &lt;&lt; x &lt;&lt; ",";
     std::cout &lt;&lt; std::endl;
    
     const auto result = std::accumulate(v.begin(), v.end(), std::make_pair(0, 0),
         [](std::pair&lt;int,int&gt; sum,int n) {
             n % 2 == 1?sum.first += n:sum.second += n;
             return sum;
         });
     auto [x, y] = result;
     std::cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; std::endl;

 }
</code></pre></div></div>

<h2 id="extra">Extra</h2>
<p>We give here a more complicated example of the remove/erase idiom. Suppose that we have a vector of strings and some of them are empty. This typically occurs when reading some delimited data from a file in which some of the fields are empty. Suppose further that we want to remove all <strong>all_blank</strong> strings from the vector. Below is the code to do just that.
First note the definition of the filter lambda: it returns true when the input is a blank character. The filter is used in the lambda res which returns an iterator to the first character that is <strong>not</strong> blank. If all characters are blank res returns the end() iterator.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    std::vector&lt;std::string&gt; vs{ "hi","  ","there","hello","  ","welcome","  ","end"};
    auto filter = [](auto c) {return c == ' ' ? true : false; };
    auto res = [&amp;](auto&amp; x) {return std::find_if_not(x.begin(), x.end(), filter); };

    std::remove_if(vs.begin(), vs.end(), [&amp;](auto&amp; is) { return res(is)== is.end(); });
  
    for (auto&amp; c : vs)
        std::cout &lt;&lt; c &lt;&lt; ",";
    std::cout&lt;&lt;std::endl;
</code></pre></div></div>
<p>You can run the above code <a href="https://repl.it/@hfarhat/remove-blank-strings">here</a>. Notice how some of the all blank strings become empty. This is the result of using move semantics.
For example</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::string s {"test"};
std::string u=std::move(s);
std::cout&lt;&lt;"("&lt;&lt;u&lt;&lt;")";
std::cout&lt;&lt;"("&lt;&lt;s&lt;&lt;")";

</code></pre></div></div>

<p>You can try this code <a href="https://repl.it/@hfarhat/move-string">here</a>. As you can see <em>u</em> “steals” the resources of <em>s</em>, i.e. its characters. When we don’t use std::move then <em>u</em> would be a copy of <em>s</em>. Actually, std::move is just static cast to an rvalue reference.</p>

<h3 id="transform">transform</h3>

<p>One of the most useful STL functions is std::transform. It is similar to the map function in functional languages (and Python). It takes</p>
<ol>
  <li>A source range, defined by start and end iterators</li>
  <li>An iterator to the beginning of the destination range. Note it is your responsibility to make sure that the destination range is large enough to fit the input</li>
  <li>A function that takes an element from the input and transforms it to another element which be stored in the destination range. In the example below, we use transform to convert each TestClass element to another with _x and _y swapped.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
   {
    std::vector&lt;TestClass&lt;1&gt;&gt; u;
    u.reserve(4);
    u.emplace_back(1, 2); u.emplace_back(3, 4); u.emplace_back(5, 2); u.emplace_back(5, 6);
    std::vector&lt;TestClass&lt;1&gt;&gt; v;
    v.resize(u.size());
    std::transform(u.begin(), u.end(), v.begin(), [](auto&amp; t) {
        int tmp = t.x();
        t.x() = t.y();
        t.y() = tmp; 
        return t; }
        );
    for (auto&amp; a : v)
        std::cout &lt;&lt; a.x() &lt;&lt; "," &lt;&lt; a.y() &lt;&lt; std::endl;
    }

</code></pre></div></div>
<p>The STL iterators interface allows us to apply many STL algorithms to almost any container. Below is an example of a few of those algorithms.</p>

<h3 id="counting">Counting</h3>

<p>For the purpose of these examples we will use a simple vector of integers. Note we don’t use the reserve function because in that case no element is created and therefore begin==end.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;

#include &lt;vector&gt; {
    int n = 20;
    std::random_device e;
    std::uniform_int_distribution&lt;&gt; dist(1, 10);
    std::vector&lt;int&gt; v;
    v.resize(n);
    std::generate(v.begin(), v.end(), [&amp;]() {return  dist(e); });
    for (auto&amp; x : v)
        std::cout &lt;&lt; x &lt;&lt; ",";
    int m = dist(e);
    std::cout &lt;&lt; "\n The number of " &lt;&lt; m &lt;&lt; " is " &lt;&lt; std::count(v.begin(), v.end(), m);
    }

</code></pre></div></div>
<p>A different version allow us to use a predicate. For example below we count the even numbers in the input as well as print the min and max in the range.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;

#include &lt;vector&gt; {
    int n = 20;
    std::random_device e;
    std::uniform_int_distribution&lt;&gt; dist(1, 10);
    std::vector&lt;int&gt; v;
    v.resize(n);
    std::generate(v.begin(), v.end(), [&amp;]() {return  dist(e); });
    for (auto&amp; x : v)
        std::cout &lt;&lt; x &lt;&lt; ",";
    int m = dist(e);
    std::cout &lt;&lt; "\n The # of evens is "
    &lt;&lt; std::count(v.begin(), v.end(),[](int i) {return i%2==0;});
    std::cout &lt;&lt; "min element is " &lt;&lt; *std::min_element(v.begin(), v.end())&lt;&lt;std::endl;
    std::cout &lt;&lt; "max element is " &lt;&lt; *std::max_element(v.begin(), v.end())&lt;&lt;std::endl;
    }

</code></pre></div></div>
<p>Many of the algorithms we are using require that the destination has enough space to copy elements to it that is why we resize the destination vector before running the algorithm.
There is a convenient back_insert_iterator that automatically calls the push_back method of the container so we don’t need to resize it beforehand.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {
    std::vector&lt;int&gt; v;
    std::back_insert_iterator itr(v);
    *itr = 1;
    *itr = 2;
    *itr = 3;
    for (auto&amp; x : v)
        std::cout &lt;&lt; x &lt;&lt; ",";
    std::cout &lt;&lt; std::endl;
    }
</code></pre></div></div>
<p>Let us use a back_insert_iterator to filter all even numbers from a container. Note that vector <strong>d</strong> has 0 size and is not resized beforehand because we don’t know how many even numbers there are in the input.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {
        int n = 20;
        std::random_device e;
        std::uniform_int_distribution&lt;&gt; dist(1, 10);
        std::vector&lt;int&gt; v;
        v.resize(n);
        std::generate(v.begin(), v.end(), [&amp;]() {return  dist(e); });
        std::vector&lt;int&gt; d;
        std::copy_if(v.begin(), v.end(), std::back_insert_iterator(d),
            [](int i) { return i % 2 ==0; });
        for(auto&amp; x:d)
            std::cout &lt;&lt; x &lt;&lt; ",";
        std::cout &lt;&lt; std::endl;
    }

</code></pre></div></div>
<p><a href="https://repl.it/@hfarhat/stdaccumulate">code</a>
<!-- ![](step1.png)
![](step2.png)
![](step3.png)
![](step4.png) --></p>


        
      </section>

      <footer class="page__meta">
        
        




      </footer>

      

      


    </div>

    
  </article>

  
  
</div>


    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->
<a href="/sitemap/">Sitemap</a>
<!-- end custom footer snippets -->

        

<div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    
    
    
    
      <li><a href="http://github.com/hikmatfarhat-ndu"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    <li><a href="http://localhost:4000/feed.xml"><i class="fa fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 Hikmat Farhat. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://github.com/academicpages/academicpages.github.io">AcademicPages</a>, a fork of <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    <script src="http://localhost:4000/assets/js/main.min.js"></script>




  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');
</script>






  </body>
</html>

