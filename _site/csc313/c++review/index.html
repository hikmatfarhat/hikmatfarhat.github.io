

<!doctype html>
<html lang="en" class="no-js">
  <head>
    

<meta charset="utf-8">



<!-- begin SEO -->









<title>Hikmat Farhat</title>







<meta property="og:locale" content="en-US">
<meta property="og:site_name" content="Hikmat Farhat">
<meta property="og:title" content="Hikmat Farhat">


  <link rel="canonical" href="http://localhost:4000/csc313/c++review/">
  <meta property="og:url" content="http://localhost:4000/csc313/c++review/">


















  <script type="application/ld+json">
    {
      "@context" : "http://schema.org",
      "@type" : "Person",
      "name" : "Hikmat Farhat",
      "url" : "http://localhost:4000",
      "sameAs" : null
    }
  </script>






<!-- end SEO -->


<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Hikmat Farhat Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">

<meta http-equiv="cleartype" content="on">
    

<!-- start custom head snippets -->

<link rel="apple-touch-icon" sizes="57x57" href="http://localhost:4000/images/apple-touch-icon-57x57.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="60x60" href="http://localhost:4000/images/apple-touch-icon-60x60.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="76x76" href="http://localhost:4000/images/apple-touch-icon-76x76.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="120x120" href="http://localhost:4000/images/apple-touch-icon-120x120.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="152x152" href="http://localhost:4000/images/apple-touch-icon-152x152.png?v=M44lzPylqQ">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:4000/images/apple-touch-icon-180x180.png?v=M44lzPylqQ">
<link rel="icon" type="image/png" href="http://localhost:4000/images/favicon-32x32.png?v=M44lzPylqQ" sizes="32x32">
<link rel="icon" type="image/png" href="http://localhost:4000/images/android-chrome-192x192.png?v=M44lzPylqQ" sizes="192x192">
<link rel="icon" type="image/png" href="http://localhost:4000/images/favicon-96x96.png?v=M44lzPylqQ" sizes="96x96">
<link rel="icon" type="image/png" href="http://localhost:4000/images/favicon-16x16.png?v=M44lzPylqQ" sizes="16x16">
<link rel="manifest" href="http://localhost:4000/images/manifest.json?v=M44lzPylqQ">
<link rel="mask-icon" href="http://localhost:4000/images/safari-pinned-tab.svg?v=M44lzPylqQ" color="#000000">
<link rel="shortcut icon" href="/images/favicon.ico?v=M44lzPylqQ">
<meta name="msapplication-TileColor" content="#000000">
<meta name="msapplication-TileImage" content="http://localhost:4000/images/mstile-144x144.png?v=M44lzPylqQ">
<meta name="msapplication-config" content="http://localhost:4000/images/browserconfig.xml?v=M44lzPylqQ">
<meta name="theme-color" content="#ffffff">
<link rel="stylesheet" href="http://localhost:4000/assets/css/academicons.css"/>

<script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML' async></script>

<!-- end custom head snippets -->

  </head>

  <body>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->
    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <button><div class="navicon"></div></button>
        <ul class="visible-links">
          <li class="masthead__menu-item masthead__menu-item--lg"><a href="http://localhost:4000/">Hikmat Farhat</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://localhost:4000/publications/">Publications</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://localhost:4000/teaching/">Teaching</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://localhost:4000/code/">Useful Code</a></li>
          
        </ul>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    





<div id="main" role="main">
  


  <div class="sidebar sticky">
  



<div itemscope itemtype="http://schema.org/Person">

  <div class="author__avatar">
    
    	<img src="http://localhost:4000/images/profile.jpg" class="author__avatar" alt="Hikmat Farhat">
    
  </div>

  <div class="author__content">
    <h3 class="author__name">Hikmat Farhat</h3>
    <p class="author__bio">Professor of Computer Science</p>
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li><i class="fa fa-fw fa-map-marker" aria-hidden="true"></i> Lebanon</li>
      
      
      
      
      
       
      
        <li><a href="https://twitter.com/hikmatfarhat"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
      
      
      
      
        <li><a href="https://www.linkedin.com/in/hikmat-farhat-3b562b41"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
      
      
      
      
      
      
        <li><a href="https://github.com/hikmatfarhat-ndu"><i class="fab fa-fw fa-github" aria-hidden="true"></i> Github</a></li>
      
      
        <li><a href="https://www.stackoverflow.com/users/13505760/hikmat-farhat"><i class="fab fa-fw fa-stack-overflow" aria-hidden="true"></i> Stackoverflow</a></li>
      
      
      
      
      
      
      
      
      
      
      
      
      
        <li><a href="http://scholar.google.com/citations?hl=en&user=bjI9-9kAAAAJ&view_op=list_works&sortby=pubdate"><i class="fas fa-fw fa-graduation-cap"></i> Google Scholar</a></li>
      
      
      
        <li><a href="https://orcid.org/0000-0002-5043-227X?lang=en"><i class="ai ai-orcid-square ai-fw"></i> ORCID</a></li>
      
      
      
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          
          
        
        
        
        
             
        
    
        </header>
      

      <section class="page__content" itemprop="text">
        
<p>When we define (declare) a variable the system reserves space in memory to store the value associated with that variable. This is the reason why we need to specify the type of the variable since the required space depends on it. For example (typically), an <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">float</code> need 4 bytes whereas <code class="language-plaintext highlighter-rouge">long</code> and <code class="language-plaintext highlighter-rouge">double</code> need 8 bytes. Because every variable is associated with a location in memory we can determine the memory address where the variable is located using the &amp; operator. Note that the &amp; operator can have different meaning depending on context.</p>
<h2 id="variables-and-references">Variables and references</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
int main(){
//a location in memory is reserved and labeled x
int x=2;
//y is just another name for the same location. no reservation is done.
int&amp; y=x;
//a location is reserved for z and the value of x is copied
int z=x;
z=17;
y=13;
//print the value of the variables and their respective addresses
std::cout&lt;&lt;"x= "&lt;&lt;x&lt;&lt;" and &lt;&lt;"&amp;x="&lt;&lt;&amp;x&lt;&lt;std::endl;
std::cout&lt;&lt;"x= "&lt;&lt;y&lt;&lt;" and &lt;&lt;"&amp;x="&lt;&lt;&amp;y&lt;&lt;std::endl;
std::cout&lt;&lt;"x= "&lt;&lt;z&lt;&lt;" and &lt;&lt;"&amp;x="&lt;&lt;&amp;z&lt;&lt;std::endl;

}
</code></pre></div></div>
<p>Note that <code class="language-plaintext highlighter-rouge">int&amp; y=x;</code> declares <em>y</em> as a reference to <em>x</em> whereas <code class="language-plaintext highlighter-rouge">&amp;x</code> gives the memory address of <em>x</em>. The different declarations used above carry to the parameters in function calls. For example,</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
void byValue(int n){
    n=17;
}
void byRef(int&amp; n){
    n=12;
}
int main(){
  int x=2;
  byValue(x);
  std::cout&lt;&lt;x&lt;&lt;std::endl;
  byRef(x);
    std::cout&lt;&lt;x&lt;&lt;std::endl;

}
</code></pre></div></div>
<p>So in the call to the function <code class="language-plaintext highlighter-rouge">byValue(x)</code> it is <strong>as if</strong> we declare <code class="language-plaintext highlighter-rouge">int n=x;</code> and therefore <em>n</em> is a <strong>copy</strong> of <em>x</em>. By contrast, <code class="language-plaintext highlighter-rouge">byRef(x)</code> is is <strong>as if</strong> we declare <code class="language-plaintext highlighter-rouge">int&amp; n=x;</code> so no copy is made and <em>n</em> is a reference to <em>x</em>.
Usually we call by reference when either we want to change the input or  when the input is large and copying becomes expensive. We can use the best of both by using a const reference</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int byCRef(const int&amp; n){
    n=37;//error cannot modify n
    return 2*n;
}
</code></pre></div></div>
<p>Also, const allows us to pass literals and temporaries.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int byT(int n){
    return 7*n;
}
int byCRef(const int &amp; n){
    n=n+1;//error n is const
    return 2*n;
}
int byRef(int&amp; n){
    n=n+1;//changes the value of parameter
    return 2*n;
}
int main(){
    byRef(2);//error cannot bind a non-const lvalue to rvalue
    byCRef(2);//OK
    byRef(byT(2));//error since the return value of byT is a temp
    byCRef(byT(2));//OK
    int&amp; r=byT(2);//error cannot bind 
    int&amp;&amp; res=byT(2);//ok
}
</code></pre></div></div>

<p>You can run the above code <a href="https://repl.it/@hfarhat/lvalue-rvalue-references">here</a>.
Since C++11 there is a new type of references called rvalue references.
The variable <em>res</em> above extends the lifetime of the temporary object created by the ByT() function.  To see that consider when the destructor is called in the following code</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
struct Test {
  int _x;
  Test(int x=0):_x(x){}
  ~Test(){
    std::cout&lt;&lt;"dtor "&lt;&lt;_x&lt;&lt;std::endl;
  }
};
Test RT(int val){
   return Test(val);
}
int main() {
Test&amp;&amp; res=RT(8);
std::cout&lt;&lt;"creating 7\n";
RT(7);
std::cout&lt;&lt;" done\n";

}
</code></pre></div></div>
<p>You can run the above code <a href="https://repl.it/@hfarhat/lvalue-rvalue-reference2">here</a>
Note that  when when an rvalue reference  is used, it is used as a lvalue reference. This is called <strong>move semantics is not passed through</strong> .For the example the following recursive function gives an error</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void doit(std::string&amp;&amp; s){
  if(s!="hello")
    doit(s);

}
</code></pre></div></div>
<p>this is a fix</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void doit(std::string&amp;&amp; s){
  if(s!="hello"){
    s="hello"; //this line so we don't go into infinite recursion
    doit(std::move(s));
  }
    
}
</code></pre></div></div>
<h2 id="return-values">Return values</h2>
<p>unless the compiler performs return value optimization (rvo) the following occurs
(in g++ or clang++ specify -fno-elide-constructors to skip optimization)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Test {
        Test(){
          std::cout&lt;&lt;"ctor\n";
        }
        Test(const Test&amp; rhs){
          std::cout&lt;&lt;"copy ctor\n";
        }
        ~Test(){
          std::cout&lt;&lt;"dtor\n";
        }
};
Test retTest(){
        return Test();
}
int main(){
  Test t=retTest();
}
</code></pre></div></div>
<p>what happens is the following</p>
<ol>
  <li>inside function <code class="language-plaintext highlighter-rouge">retTest()</code> an object of type Test is created on the stack</li>
  <li>a tmp object of type Test is copy constructed from that object</li>
  <li>the object on the stack is dtored</li>
  <li>t in main is copy ctored from the tmp</li>
  <li>tmp is destroyed</li>
  <li>when main exists t is destroyed
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$g++-10 -fno-elide-constructors -std=c++11 rvopt.cpp
$./a.out
ctor
copy ctor
dtor
copy ctor
dtor
dtor
$g++-10 -std=c++20 rvopt.cpp
$./a.out
ctor
dtor
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="pointers">Pointers</h2>
<p>A pointer variable is a variable that holds and address. We say variable <em>p</em> points to variable <em>x</em> if <em>p</em> holds the address of <em>x</em>: <code class="language-plaintext highlighter-rouge">int *p=&amp;x;</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(){
int x=17,y=45;
int* p=&amp;x;
std::cout&lt;&lt;p&lt;&lt;std::endl;//prints the value of p, i.e. the address of x
std::cout&lt;&lt;*p&lt;&lt;std::endl;//prints the value store at the location p, i.e. x
*p=23;//change the value of x
p=&amp;y;//p now stores the address of y
}
</code></pre></div></div>
<p>Pointers usually are used when we need to dynamically allocate memory.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(){
    int *p=new int;//reserve space for int. Value undefined
    int *q=new int(8);//reserve space for int and store 8
    *p=55;//store value 55 at address p
    delete p;//release the reserved memory;
}
</code></pre></div></div>
<h2 id="templates">Templates</h2>

<p>On many occasions we write multiple versions of the same code to handle different types. For example suppose we want to write a function to add two numbers (using the + operator) we write</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int add(int x,int y){
    return x+y;
}
int add(double x,double y){
    return x+y;
}

</code></pre></div></div>
<p>Recall also that the + operator can be used to concatenate strings so we have to add that also. Since the all of those versions only the type changes, c++ allows us to pass the type as a parameters using templates.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;string&gt;

template&lt;typename T&gt;
T add(T x,T y){
    return x+y;
}
int main(){
    int x=2,y=3;
    double u=3.4,v=3;
    std::string s="hello",k="there";

    std::cout&lt;&lt;add(x,y)&lt;&lt;std::endl;
    std::cout&lt;&lt;add(u,v)&lt;&lt;std::endl;
    std::cout&lt;&lt;add(s,k)&lt;&lt;std::endl;
}

</code></pre></div></div>

<p>In the above example the compiler automatically deduces the type which sometimes it cannot and we have to specify it as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add&lt;int&gt;(x,y);
add&lt;double(u,v);
add&lt;std::string&gt;(s,k);

</code></pre></div></div>

<p>Note that the template is instantiated <strong>as needed</strong> at compile time. Also, we can pass parameters to the template other than types. For example</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;int n&gt;
void doit(){
    int a[n];
}
</code></pre></div></div>

<h1 id="classes">Classes</h1>

<p>In C++ new types are created using classes. Once a class is defined new objects can be instantiated from such a class. Minimal syntax of a (useless) class</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Test{};
int main(){
    Test t;
}
</code></pre></div></div>

<p>A class can have <strong>member variables</strong> and <strong>member functions</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Test{
    int _x;
    public:
    int&amp; x(){
        return _x;
    }
    
};
int main(){
    Test t;// at this point _x is undefined
    t.x()=17;
}
</code></pre></div></div>
<p>By default all members of a class are <strong>private</strong> and hence inaccessible from outside the scope of the object. To make a member accessible we use the keyword <strong>public</strong>. Note that the <strong>member function</strong> <code class="language-plaintext highlighter-rouge">x()</code> returns a <strong>reference</strong> to _x and this allows us to change the value of _x. We can use pointers as usual where the code below is equivalent to the one above but using the arrow instead of the dot operator.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(){
    Test * p=new Test();
    p-&gt;x()=17;
}
</code></pre></div></div>

<p>In fact the private and public qualifiers can be used for any and all members. For example</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Test {
    private: int _x;//_x is private
    public: int _y;// _y is public
     int _z;// _z is public. The keyword carries over until it changes
     private: void f(){}
     public: int&amp; x(){return _x;}
}
</code></pre></div></div>
<p>But usually all public members are grouped together using a single keyword and the same for private members;</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(){
    Test t;
    t._x;//error _x is inaccessible
    t._y=t._z;//OK both are public
    t.x();//OK
    t.f();//Error f is inaccessible
}
</code></pre></div></div>

<h2 id="constructors-and-destructors">Constructors and destructors</h2>

<p>For builtin types like int and double a variable is “created” (memory is reserved) when the variable is declared. Once the variable is out of scope is it “destroyed” (memory is released. The same thing is done for objects instantiated from classes. This is done by using <strong>constructor</strong> and <strong>destructor</strong>. When one don’t supply our own versions a default version is used by the compiler which basically calls the constructors and destructors of the member variables.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Test {
    public:
    int _x;
    double _y;
}
int main(){
    Test t;
    std::cout&lt;&lt;t._x&lt;&lt;std::endl;
    std::cout&lt;&lt;t._y&lt;&lt;std::endl;


}
</code></pre></div></div>
<p>No constructor is supplied so the compiler uses a default that creates variables _x and _y. The output is</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0
0
</code></pre></div></div>

<h1 id="extra">Extra</h1>

<h2 id="constructors">Constructors…</h2>

<p>A constructor builds an object bottom up.</p>
<ol>
  <li>the constructor of the base class (if any) is called</li>
  <li>members instructors are called</li>
  <li>Finally the constructor body is executed.</li>
</ol>

<p>For example</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Item {
    Item(){std::cout&lt;&lt;"Item ctor\n";}
    Item(int i){std::cout&lt;&lt;""Item ctor with input\n";}
};
struct Test {
    Item _i;
    int x;
};
void noinit(){
    int x=12,y=77,z=99;
    Test t;
    std::cout&lt;&lt;t.x&lt;&lt;std::endl;
}
void init(){
    int x=12,y=77,z=99;
    Test t {};//initialize to zero
    std::cout&lt;&lt;t.x&lt;&lt;std::endl;
}
int main(){
    noinit();
    init();
}
</code></pre></div></div>
<p>Run to get the output</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>item ctor
723520304
item ctor
0
</code></pre></div></div>
<p>As we can see from the above example built-in types are <strong>not</strong> initiaized: some times they are zero sometimes they are not, it depends on the compiler. For class types the default constructor is called. We can control the constructor and the initialization of members as follows</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Test {
    Test(int x,int i):_x(x),_i(i){}
}
</code></pre></div></div>

        
      </section>

      <footer class="page__meta">
        
        




      </footer>

      

      


    </div>

    
  </article>

  
  
</div>


    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->
<a href="/sitemap/">Sitemap</a>
<!-- end custom footer snippets -->

        

<div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    
    
    
    
      <li><a href="http://github.com/hikmatfarhat-ndu"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    <li><a href="http://localhost:4000/feed.xml"><i class="fa fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 Hikmat Farhat. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://github.com/academicpages/academicpages.github.io">AcademicPages</a>, a fork of <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    <script src="http://localhost:4000/assets/js/main.min.js"></script>




  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');
</script>






  </body>
</html>

